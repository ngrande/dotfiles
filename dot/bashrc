#
# ~/.bashrc
#

# If not running interactively, don't do anything
[[ $- != *i* ]] && return
# see also: https://unix.stackexchange.com/questions/257571/why-does-bashrc-check-whether-the-current-shell-is-interactive#257613

# prevent new terminals to open a new session in the same directory as another terminal is in
cd

# +++ ATTENTION +++
# start tmux with every shell start
# If not running interactively, do not do anything
[[ $- != *i* ]] && return
[[ -z "$TMUX" ]] && exec tmux
# +++++++++++++++++

# prevent history commands from executing by ! or !! but wait for execution by user
shopt -s histverify

# notify user if restart necessary
bold=$(tput bold)
normal=$(tput sgr0)
# get the version part (like "5.0")
uname_r=$(uname -r | awk -F - '{print $1}')
kernel_vers=$(echo $uname_r | awk -F . '{print $1"."$2}')
if [ ${#uname_r} -gt 4 ]; then
	# append patch version (like "5.0.3")
	kernel_vers=$kernel_vers"."$(echo $uname_r | awk -F . '{print $3}')
fi

# get the rel part (like "arch1-1")
kernel_rel=$(uname -r | awk -F - '{print $2"-"$3}')
# combine both to compare to package name (like "5.0.arch1-1")
installed=$(pacman -Q linux | awk '{print $2}')

active=("$kernel_vers.$kernel_rel")

if [ $active != $installed ]; then
	echo "${bold}you have a newer kernel version installed ($installed) - please restart your machine${normal}"
fi

# after greeting include additional file with commands (won't be commited)
if [ -f $HOME/.bashrc_ext ]; then
	. $HOME/.bashrc_ext
fi

# alias's
alias diff='diff --color=auto'
alias dir='dir --color=auto'
alias vdir='vdir --color=auto'
alias grep='grep --color=auto'
alias fgrep='fgrep --color=auto'
alias egrep='egrep --color=auto'
alias ls='ls -hrt --color=auto'
alias ll='ls -Al'
# force tmux to assume 256 color mode
alias tmux='tmux -2'
# this might cause some trouble
alias python='bpython'
# gcc output color
export GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01'
# less colorized
export LESS=-R
export LESS_TERMCAP_mb=$'\E[1;31m'     # begin bold
export LESS_TERMCAP_md=$'\E[1;36m'     # begin blink
export LESS_TERMCAP_me=$'\E[0m'        # reset bold/blink
export LESS_TERMCAP_so=$'\E[01;44;33m' # begin reverse video
export LESS_TERMCAP_se=$'\E[0m'        # reset reverse video
export LESS_TERMCAP_us=$'\E[1;32m'     # begin underline
export LESS_TERMCAP_ue=$'\E[0m'        # reset underline
# grep color
export GREP_COLOR="1;32"

# man color hack
man() {
    LESS_TERMCAP_md=$'\e[01;31m' \
    LESS_TERMCAP_me=$'\e[0m' \
    LESS_TERMCAP_se=$'\e[0m' \
    LESS_TERMCAP_so=$'\e[01;44;33m' \
    LESS_TERMCAP_ue=$'\e[0m' \
    LESS_TERMCAP_us=$'\e[01;32m' \
    command man "$@"
}

# pacman and aur helper
alias paorph='yay -Rns $(yay -Qdtq) '
alias paup='yay -Syu --ignore linux '

# btrfs
#alias buh='sudo btrfs filesystem usage /home'
alias buh='sudo echo ""; echo "/home usage"; sudo btrfs filesystem usage /home | grep -E "^\s+(Used|Free \(estimated\)):";echo ""'
#alias bur='sudo btrfs filesystem usage /'
alias bur='sudo echo ""; echo "/ usage"; sudo btrfs filesystem usage / | grep -E "^\s+(Used|Free \(estimated\)):";echo ""'

# shell prompt colors
# TRUE COLOR: 38;2;R;G;Bm (don't know what the 38;2; is for...)
TRUE_COLOR="\[\e[38;2;255;3;160m\]" # PINK
NO_GIT_COLOR="\[\e[38;2;255;135;200m\]" # light pink
GIT_COLOR="\[\e[1;36m\]" # CYAN
# USE COLOR PALETTE OF Tomorrow-Night vim scheme
GIT_CLEAN_COLOR="\[\e[38;2;127;255;0m\]" # GREEN
GIT_AHEAD_COLOR="\[\e[38;2;238;130;238m\]" # PURPLE
GIT_BEHIND_COLOR="\[\e[38;2;253;151;32m\]" # ORANGE
GIT_CHANGES_COLOR="\[\e[38;2;249;39;114m\]" # RED
GIT_DETACHED_COLOR="\[\e[48;2;249;39;114m\]" # BACKGROUND RED
NO_COLOR="\[\e[m\]"

function _git_prompt { 
	local cwd="${NO_GIT_COLOR}\w${NO_COLOR}" 
	local branch="" 
	local git_status="" 

	pwd | grep -E dev-linux[0-9]+ 1> /dev/null
	if [[ $? -eq 0 ]]; then
		return
	fi
	
	git_status="$(LANG=C git status 2> /dev/null)" 
	if [[ $? -eq 0 ]]; then 
		local rela_dir="$(git rev-parse --show-prefix)" 
		rela_dir="${rela_dir%/}" 
		local repo_root="${PWD%$rela_dir}" 
		[[ "$repo_root" =~ ^"$HOME"(/|$) ]] && repo_root="~${repo_root#$HOME}" 

		cwd="${GIT_COLOR}${repo_root}${rela_dir}${NO_COLOR}" 

		local pattern="^(# )?On branch ([^${IFS}]*)" 
		if [[ ${git_status} =~ ${pattern} ]]; then 
			local branch_name=${BASH_REMATCH[2]} 
			local branch_color="" 
			if [[ ${git_status} =~ (working (tree|directory) clean) ]]; then 
				branch_color=${GIT_CLEAN_COLOR}
				if [[ ${git_status} =~ (Your branch is ahead) ]]; then 
					branch_color=${GIT_AHEAD_COLOR}
				elif [[ "$(git log --all --not --remotes --tags --oneline)" ]]; then 
					branch_color=${GIT_BEHIND_COLOR}
				fi
			else
				branch_color=${GIT_CHANGES_COLOR}
			fi
			
			#branch="${TRUE_COLOR}[${NO_COLOR}\[$branch_color\]$branch_name\[${NO_COLOR}\]${TRUE_COLOR}]${NO_COLOR}" 
			branch="${TRUE_COLOR}[${NO_COLOR}${branch_color}${branch_name}${NO_COLOR}${TRUE_COLOR}]${NO_COLOR}" 
		fi
		
		if [[ ${git_status} =~ (HEAD detached) ]]; then 
			# branch="[\[\e[1;31;46m\]DETACHED HEAD\[\e[0m\]]" 
			#branch="${TRUE_COLOR}[${NO_COLOR}\[${GIT_DETACHED_COLOR}\]DETACHED HEAD\[${NO_COLOR}\]${TRUE_COLOR}]${NO_COLOR}"
			branch="${TRUE_COLOR}[${NO_COLOR}${GIT_DETACHED_COLOR}DETACHED HEAD${NO_COLOR}${TRUE_COLOR}]${NO_COLOR}"
		fi
	fi

	# PS1="\[\e]0;\u@\h:\w\a\e[0m\]\u@\h:${cwd}${branch}\\$ "
	#PS1="\[\e]0;\u@\h:\w\a\e[0m${TRUE_COLOR}\u@\h:${NO_COLOR}${cwd}${branch}${TRUE_COLOR}\$${NO_COLOR}\] "
	PS1="\[\e]0;\u@\h:\w\a\e[0m\]${TRUE_COLOR}\u@\h:${NO_COLOR}${cwd}${branch}${TRUE_COLOR}\$${NO_COLOR} "
} 

PROMPT_COMMAND=_git_prompt
#PS1='\u@\h \W >> '
 
HISTTIMEFORMAT="[%Y-%m-%d %T %Z] "
HISTCONTROL=erasedups
HISTSIZE=100000
HISTFILESIZE=100000

# add my scripts to PATH
PATH=$PATH:$HOME/projects/scripts
PATH=$PATH:$HOME/.local/bin
export EDITOR=vim

# greeting with logo
archey3
